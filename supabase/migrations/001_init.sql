create extension if not exists postgis; create extension if not exists btree_gist;
create type place_status as enum ('active','hidden'); create type tip_status as enum ('pending','published','hidden','flagged');
create type media_status as enum ('pending','approved','rejected'); create type like_target as enum ('place','tip','photo','list');
create type feed_event_type as enum ('visited','new_tip','new_photo','earned_badge','follow');
create table region(id bigserial primary key, slug text unique not null, name_en text not null, level smallint not null default 2, country_code char(2), geom geometry(MultiPolygon,4326));
create table category(id bigserial primary key, slug text unique not null, name_en text not null);
create table place(id bigserial primary key, region_id bigint references region(id), category_id bigint references category(id), slug text unique not null, name_en text not null, lat double precision not null, lng double precision not null, geom geography(Point,4326) generated always as (ST_SetSRID(ST_MakePoint(lng,lat),4326)::geography) stored, country_code char(2) not null, status place_status default 'active', popularity_score numeric(5,2) default 0, source text default 'manual', verified boolean default false);
create table tag(id bigserial primary key, slug text unique not null, name_en text not null);
create table place_tag(place_id bigint references place(id) on delete cascade, tag_id bigint references tag(id) on delete cascade, primary key(place_id, tag_id));
create table "user"(id uuid primary key default gen_random_uuid(), username text unique, avatar_url text, is_private boolean default false, bio text, home_country char(2), settings jsonb default '{}'::jsonb, created_at timestamptz default now());
create table visit(user_id uuid references "user"(id) on delete cascade, place_id bigint references place(id) on delete cascade, visited boolean not null, rating smallint, note text, visited_at date, primary key(user_id, place_id));
create table list(id bigserial primary key, slug text unique not null, title text not null, country_code char(2), category text not null);
create table list_place(list_id bigint references list(id) on delete cascade, place_id bigint references place(id) on delete cascade, order_idx int, primary key(list_id, place_id));
create table follow(follower_id uuid references "user"(id) on delete cascade, following_id uuid references "user"(id) on delete cascade, created_at timestamptz default now(), primary key(follower_id, following_id));
create table tip(id bigserial primary key, place_id bigint references place(id) on delete cascade, user_id uuid references "user"(id) on delete cascade, body text not null, lang text default 'en', photos_count int default 0, status tip_status default 'pending', created_at timestamptz default now(), updated_at timestamptz default now());
create table photo(id bigserial primary key, place_id bigint references place(id) on delete cascade, user_id uuid references "user"(id) on delete cascade, storage_url text not null, width int, height int, blurhash text, status media_status default 'pending', created_at timestamptz default now());
create table "like"(user_id uuid references "user"(id) on delete cascade, target_type like_target not null, target_id bigint not null, created_at timestamptz default now(), primary key(user_id, target_type, target_id));
create table feed_event(id bigserial primary key, type feed_event_type not null, actor_user_id uuid references "user"(id) on delete cascade, place_id bigint null references place(id) on delete set null, object_id bigint null, created_at timestamptz default now(), visibility text default 'public');
create index place_gist on place using gist (geom); create index place_country_cat_pop_idx on place(country_code, category_id, popularity_score desc);
create index tip_published_idx on tip(status); create index photo_approved_idx on photo(status);
alter table visit enable row level security; create policy "own visits" on visit for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
alter table follow enable row level security; create policy "read follows" on follow for select using (true); create policy "insert self" on follow for insert with check (auth.uid() = follower_id);
